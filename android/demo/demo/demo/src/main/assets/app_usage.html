<!DOCTYPE html>
<!-- saved from url=(0066)http://oss-static.detu.com/application/views/csimum/app_usage.html -->
<html data-dpr="1" style="font-size: 37.5px;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <meta name="format-detection" content="telephone=no">
    <meta name="baidu-site-verification" content="7X307bxGn6">
    <title></title>
    <meta name="keywords" content="白犀牛">
    <meta name="description" content="白犀牛">
    
    <script type="text/javascript">!function(a,b){function c(){var b=f.getBoundingClientRect().width;b/i>540&&(b=540*i);var c=b/10;f.style.fontSize=c+"px",k.rem=a.rem=c}var d,e=a.document,f=e.documentElement,g=e.querySelector('meta[name="viewport"]'),h=e.querySelector('meta[name="flexible"]'),i=0,j=0,k=b.flexible||(b.flexible={});if(g){console.warn("将根据已有的meta标签来设置缩放比例");var l=g.getAttribute("content").match(/initial\-scale=([\d\.]+)/);l&&(j=parseFloat(l[1]),i=parseInt(1/j))}else if(h){var m=h.getAttribute("content");if(m){var n=m.match(/initial\-dpr=([\d\.]+)/),o=m.match(/maximum\-dpr=([\d\.]+)/);n&&(i=parseFloat(n[1]),j=parseFloat((1/i).toFixed(2))),o&&(i=parseFloat(o[1]),j=parseFloat((1/i).toFixed(2)))}}if(!i&&!j){var p=a.navigator.userAgent,q=(!!p.match(/android/gi),!!p.match(/iphone/gi)),r=q&&!!p.match(/OS 9_3/),s=a.devicePixelRatio;i=q&&!r?s>=3&&(!i||i>=3)?3:s>=2&&(!i||i>=2)?2:1:1,j=1/i}if(f.setAttribute("data-dpr",i),!g)if(g=e.createElement("meta"),g.setAttribute("name","viewport"),g.setAttribute("content","initial-scale="+j+", maximum-scale="+j+", minimum-scale="+j+", user-scalable=no"),f.firstElementChild)f.firstElementChild.appendChild(g);else{var t=e.createElement("div");t.appendChild(g),e.write(t.innerHTML)}a.addEventListener("resize",function(){clearTimeout(d),d=setTimeout(c,300)},!1),a.addEventListener("pageshow",function(a){a.persisted&&(clearTimeout(d),d=setTimeout(c,300))},!1),"complete"===e.readyState?e.body.style.fontSize=12*i+"px":e.addEventListener("DOMContentLoaded",function(){e.body.style.fontSize=12*i+"px"},!1),c(),k.dpr=a.dpr=i,k.refreshRem=c,k.rem2px=function(a){var b=parseFloat(a)*this.rem;return"string"==typeof a&&a.match(/rem$/)&&(b+="px"),b},k.px2rem=function(a){var b=parseFloat(a)/this.rem;return"string"==typeof a&&a.match(/px$/)&&(b+="rem"),b}}(window,window.lib||(window.lib={}));</script>
    <script>/*!
 * Vue.js v2.5.16
 * (c) 2014-2018 Evan You
 * Released under the MIT License.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Vue = factory());
}(this, (function () { 'use strict';

/*  */

var emptyObject = Object.freeze({});

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value e.g. [object Object]
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : typeof val === 'object'
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it... e.g.
 * PhantomJS 1.x. Technically we don't need this anymore since native bind is
 * now more performant in most browsers, but removing it would be breaking for
 * code that was able to run in PhantomJS 1.x, so this must be kept for
 * backwards compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }

  boundFn._length = fn.length;
  return boundFn
}

function nativeBind (fn, ctx) {
  return fn.bind(ctx)
}

var bind = Function.prototype.bind
  ? nativeBind
  : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/**
 * Return same value
 */
var identity = function (_) { return _; };

/**
 * Generate a static keys string from compiler modules.
 */
function genStaticKeys (modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || [])
  }, []).join(',')
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured'
];

/*  */

var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
})

/*  */

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = (function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

{
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm || {};
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */


var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget (_target) {
  if (Dep.target) { targetStack.push(Dep.target); }
  Dep.target = _target;
}

function popTarget () {
  Dep.target = targetStack.pop();
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    vnode.children,
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.isCloned = true;
  return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto
      ? protoAugment
      : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  if (!getter && arguments.length === 2) {
    val = obj[key];
  }
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if ("development" !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if ("development" !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "development" !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if ("development" !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    "development" !== 'production' && warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
{
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "development" !== 'production' && warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    "development" !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!/^[a-zA-Z][\w-]*$/.test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'can only contain alphanumeric characters and the hyphen, ' +
      'and must start with a letter.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if ("development" !== 'production' && warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */

function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if ("development" !== 'production' && isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn(
      "Invalid prop: type check failed for prop \"" + name + "\"." +
      " Expected " + (expectedTypes.map(capitalize).join(', ')) +
      ", got " + (toRawType(value)) + ".",
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isSameType (a, b) {
  return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}

/*  */

function handleError (err, vm, info) {
  if (vm) {
    var cur = vm;
    while ((cur = cur.$parent)) {
      var hooks = cur.$options.errorCaptured;
      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;
            if (capture) { return }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }
  globalHandleError(err, vm, info);
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      logError(e, null, 'config.errorHandler');
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */
/* globals MessageChannel */

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using both microtasks and (macro) tasks.
// In < 2.4 we used microtasks everywhere, but there are some scenarios where
// microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using (macro) tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use microtask by default, but expose a way to force (macro) task when
// needed (e.g. in event handlers attached by v-on).
var microTimerFunc;
var macroTimerFunc;
var useMacroTask = false;

// Determine (macro) task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else if (typeof MessageChannel !== 'undefined' && (
  isNative(MessageChannel) ||
  // PhantomJS
  MessageChannel.toString() === '[object MessageChannelConstructor]'
)) {
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = flushCallbacks;
  macroTimerFunc = function () {
    port.postMessage(1);
  };
} else {
  /* istanbul ignore next */
  macroTimerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

// Determine microtask defer implementation.
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  microTimerFunc = function () {
    p.then(flushCallbacks);
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc;
}

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a (macro) task instead of a microtask.
 */
function withMacroTask (fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true;
    var res = fn.apply(null, arguments);
    useMacroTask = false;
    return res
  })
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    if (useMacroTask) {
      macroTimerFunc();
    } else {
      microTimerFunc();
    }
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

var mark;
var measure;

{
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

{
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments)
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  vm
) {
  var name, def, cur, old, event;
  for (name in on) {
    def = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    /* istanbul ignore if */
    if (isUndef(cur)) {
      "development" !== 'production' && warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor,
  context
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function () {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      "development" !== 'production' && warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject(
                "timeout (" + (res.timeout) + "ms)"
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn, once) {
  if (once) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break
        }
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, ("event handler for \"" + event + "\""));
        }
      }
    }
    return vm
  };
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  var slots = {};
  if (!children) {
    return slots
  }
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

function resolveScopedSlots (
  fns, // see flow/vnode
  res
) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(
        vm.$el, vnode, hydrating, false /* removeOnly */,
        vm.$options._parentElm,
        vm.$options._refElm
      );
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if ("development" !== 'production' && config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(("vue " + name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(("vue " + name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    parentVnode.data.scopedSlots || // has new scoped slots
    vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, (hook + " hook"));
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */


var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ("development" !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$1 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$1; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = expOrFn.toString();
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      "development" !== 'production' && warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
    var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
    var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    "development" !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
      "development" !== 'production' && warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if ("development" !== 'production' && getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : userDef.get
      : noop;
    sharedPropertyDefinition.set = userDef.set
      ? userDef.set
      : noop;
  }
  if ("development" !== 'production' &&
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    {
      if (methods[key] == null) {
        warn(
          "Method \"" + key + "\" has an undefined value in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  {
    dataDef.set = function (newData) {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      }
    });
    toggleObserving(true);
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject).filter(function (key) {
        /* istanbul ignore next */
        return Object.getOwnPropertyDescriptor(inject, key).enumerable
      })
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    (ret)._isVList = true;
  }
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if ("development" !== 'production' && !isObject(bindObject)) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        );
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes) {
      if ("development" !== 'production' && slotNodes._rendered) {
        warn(
          "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
          "- this will likely cause render errors.",
          this
        );
      }
      slotNodes._rendered = true;
    }
    nodes = slotNodes || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

function isKeyNotMatch (expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1
  } else {
    return expect !== actual
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInKeyCode,
  eventKeyName,
  builtInKeyName
) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName)
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode)
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
      "development" !== 'production' && warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "development" !== 'production' && warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () { return resolveSlots(children, parent); };

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = data.scopedSlots || emptyObject;
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options)
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options);
    }
    return res
  }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */




// Register the component hook to weex native render engine.
// The hook will be triggered by native, not javascript.


// Updates the state of the component to weex native render engine.

/*  */

// https://github.com/Hanks10100/weex-native-directive/tree/master/component

// listening on native callback

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (
    vnode,
    hydrating,
    parentElm,
    refElm
  ) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance,
        parentElm,
        refElm
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component
  /* istanbul ignore if */
  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent, // activeInstance in lifecycle state
  parentElm,
  refElm
) {
  var options = {
    _isComponent: true,
    parent: parent,
    _parentVnode: vnode,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    hooks[key] = componentVNodeHooks[key];
  }
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
    "development" !== 'production' && warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if ("development" !== 'production' &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      );
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (
        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  }
}

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    // reset _rendered flag on slots for duplicate slot check
    {
      for (var key in vm.$slots) {
        // $flow-disable-line
        vm.$slots[key]._rendered = false;
      }
    }

    if (_parentVnode) {
      vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject;
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      {
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if ("development" !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    {
      initProxy(vm);
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified
}

function dedupe (latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res
  } else {
    return latest
  }
}

function Vue (options) {
  if ("development" !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if ("development" !== 'production' && name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if ("development" !== 'production' && type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */

function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache, key, this$1.keys);
    }
  },

  mounted: function mounted () {
    var this$1 = this;

    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) { return matches(val, name); });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) { return !matches(val, name); });
    });
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
}

var builtInComponents = {
  KeepAlive: KeepAlive
}

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.5.16';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isPreTag = function (tag) { return tag === 'pre'; };

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      "development" !== 'production' && warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setStyleScope (node, scopeId) {
  node.setAttribute(scopeId, '');
}


var nodeOps = Object.freeze({
	createElement: createElement$1,
	createElementNS: createElementNS,
	createTextNode: createTextNode,
	createComment: createComment,
	insertBefore: insertBefore,
	removeChild: removeChild,
	appendChild: appendChild,
	parentNode: parentNode,
	nextSibling: nextSibling,
	tagName: tagName,
	setTextContent: setTextContent,
	setStyleScope: setStyleScope
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
}

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove () {
      if (--remove.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove.listeners = listeners;
    return remove
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1 (vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }

  var creatingElmInVPre = 0;

  function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if ("development" !== 'production' && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys (children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn(
            ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
            vnode.context
          );
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || (data && data.pre);
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true
    }
    // assert node match
    {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ("development" !== 'production' &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ("development" !== 'production' &&
                typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || (
        !isUnknownElement$$1(vnode, inVPre) &&
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm$1,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
}

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
]

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr (el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.
    /* istanbul ignore if */
    if (
      isIE && !isIE9 &&
      el.tagName === 'TEXTAREA' &&
      key === 'placeholder' && !el.__ieph
    ) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };
      el.addEventListener('input', blocker);
      // $flow-disable-line
      el.__ieph = true; /* IE placeholder patched */
    }
    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
}

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
}

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters (exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
    } else if (
      c === 0x7C && // pipe
      exp.charCodeAt(i + 1) !== 0x7C &&
      exp.charCodeAt(i - 1) !== 0x7C &&
      !curly && !square && !paren
    ) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22: inDouble = true; break         // "
        case 0x27: inSingle = true; break         // '
        case 0x60: inTemplateString = true; break // `
        case 0x28: paren++; break                 // (
        case 0x29: paren--; break                 // )
        case 0x5B: square++; break                // [
        case 0x5D: square--; break                // ]
        case 0x7B: curly++; break                 // {
        case 0x7D: curly--; break                 // }
      }
      if (c === 0x2f) { // /
        var j = i - 1;
        var p = (void 0);
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') { break }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter () {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression
}

function wrapFilter (exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return ("_f(\"" + filter + "\")(" + exp + ")")
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return ("_f(\"" + name + "\")(" + exp + (args !== ')' ? ',' + args : args))
  }
}

/*  */

function baseWarn (msg) {
  console.error(("[Vue compiler]: " + msg));
}

function pluckModuleFunction (
  modules,
  key
) {
  return modules
    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
    : []
}

function addProp (el, name, value) {
  (el.props || (el.props = [])).push({ name: name, value: value });
  el.plain = false;
}

function addAttr (el, name, value) {
  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
  el.plain = false;
}

// add a raw attr (use this in preTransforms)
function addRawAttr (el, name, value) {
  el.attrsMap[name] = value;
  el.attrsList.push({ name: name, value: value });
}

function addDirective (
  el,
  name,
  rawName,
  value,
  arg,
  modifiers
) {
  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
  el.plain = false;
}

function addHandler (
  el,
  name,
  value,
  modifiers,
  important,
  warn
) {
  modifiers = modifiers || emptyObject;
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if (
    "development" !== 'production' && warn &&
    modifiers.prevent && modifiers.passive
  ) {
    warn(
      'passive and prevent can\'t be used together. ' +
      'Passive handler can\'t prevent default event.'
    );
  }

  // check capture modifier
  if (modifiers.capture) {
    delete modifiers.capture;
    name = '!' + name; // mark the event as captured
  }
  if (modifiers.once) {
    delete modifiers.once;
    name = '~' + name; // mark the event as once
  }
  /* istanbul ignore if */
  if (modifiers.passive) {
    delete modifiers.passive;
    name = '&' + name; // mark the event as passive
  }

  // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.
  if (name === 'click') {
    if (modifiers.right) {
      name = 'contextmenu';
      delete modifiers.right;
    } else if (modifiers.middle) {
      name = 'mouseup';
    }
  }

  var events;
  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = {
    value: value.trim()
  };
  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }

  el.plain = false;
}

function getBindingAttr (
  el,
  name,
  getStatic
) {
  var dynamicValue =
    getAndRemoveAttr(el, ':' + name) ||
    getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue)
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue)
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr (
  el,
  name,
  removeFromMap
) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break
      }
    }
  }
  if (removeFromMap) {
    delete el.attrsMap[name];
  }
  return val
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel (
  el,
  value,
  modifiers
) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression =
      "(typeof " + baseValueExpression + " === 'string'" +
      "? " + baseValueExpression + ".trim()" +
      ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: ("(" + value + ")"),
    expression: ("\"" + value + "\""),
    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode (
  value,
  assignment
) {
  var res = parseModel(value);
  if (res.key === null) {
    return (value + "=" + assignment)
  } else {
    return ("$set(" + (res.exp) + ", " + (res.key) + ", " + assignment + ")")
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

var len;
var str;
var chr;
var index$1;
var expressionPos;
var expressionEndPos;



function parseModel (val) {
  // Fix https://github.com/vuejs/vue/pull/7730
  // allow v-model="obj.val " (trailing whitespace)
  val = val.trim();
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');
    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      }
    } else {
      return {
        exp: val,
        key: null
      }
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  }
}

function next () {
  return str.charCodeAt(++index$1)
}

function eof () {
  return index$1 >= len
}

function isStringStart (chr) {
  return chr === 0x22 || chr === 0x27
}

function parseBracket (chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue
    }
    if (chr === 0x5B) { inBracket++; }
    if (chr === 0x5D) { inBracket--; }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break
    }
  }
}

function parseString (chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model (
  el,
  dir,
  _warn
) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1(
        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
        "File inputs are read only. Use a v-on:change listener instead."
      );
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false
  } else {
    warn$1(
      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
      "v-model is not supported on this element type. " +
      'If you are working with contenteditable, it\'s recommended to ' +
      'wrap a library dedicated for that purpose inside a custom component.'
    );
  }

  // ensure runtime directive metadata
  return true
}

function genCheckboxModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked',
    "Array.isArray(" + value + ")" +
    "?_i(" + value + "," + valueBinding + ")>-1" + (
      trueValueBinding === 'true'
        ? (":(" + value + ")")
        : (":_q(" + value + "," + trueValueBinding + ")")
    )
  );
  addHandler(el, 'change',
    "var $$a=" + value + "," +
        '$$el=$event.target,' +
        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
    'if(Array.isArray($$a)){' +
      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
          '$$i=_i($$a,$$v);' +
      "if($$el.checked){$$i<0&&(" + (genAssignmentCode(value, '$$a.concat([$$v])')) + ")}" +
      "else{$$i>-1&&(" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + ")}" +
    "}else{" + (genAssignmentCode(value, '$$c')) + "}",
    null, true
  );
}

function genRadioModel (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect (
  el,
  value,
  modifiers
) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" +
    ".call($event.target.options,function(o){return o.selected})" +
    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
    "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + (genAssignmentCode(value, assignment));
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel (
  el,
  value,
  modifiers
) {
  var type = el.attrsMap.type;

  // warn if v-bind:value conflicts with v-model
  // except for inputs with v-bind:type
  {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
    if (value$1 && !typeBinding) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(
        binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " +
        'because the latter already expands to a value binding internally'
      );
    }
  }

  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy
    ? 'change'
    : type === 'range'
      ? RANGE_TOKEN
      : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', ("(" + value + ")"));
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler (handler, event, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

function add$1 (
  event,
  handler,
  once$$1,
  capture,
  passive
) {
  handler = withMacroTask(handler);
  if (once$$1) { handler = createOnceHandler(handler, event, capture); }
  target$1.addEventListener(
    event,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  event,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    event,
    handler._withTask || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
}

/*  */

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isNotInFocusAndDirty(elm, checkVal) ||
    isDirtyWithModifiers(elm, checkVal)
  ))
}

function isNotInFocusAndDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isDirtyWithModifiers (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.lazy) {
      // inputs with lazy should only be updated when not in focus
      return false
    }
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal)
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim()
    }
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
}

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (
        childNode && childNode.data &&
        (styleData = normalizeStyleData(childNode.data))
      ) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
}

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def) {
  if (!def) {
    return
  }
  /* istanbul ignore else */
  if (typeof def === 'object') {
    var res = {};
    if (def.css !== false) {
      extend(res, autoCssTransition(def.name || 'v'));
    }
    extend(res, def);
    return res
  } else if (typeof def === 'string') {
    return autoCssTransition(def)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

function toMs (s) {
  return Number(s.slice(0, -1)) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if ("development" !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if ("development" !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {}

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
]

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted (el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd);
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    "development" !== 'production' && warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (!value === !oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
}

var platformDirectives = {
  model: directive,
  show: show
}

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if ("development" !== 'production' && children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if ("development" !== 'production' &&
      mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
}

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  beforeUpdate: function beforeUpdate () {
    // force removing pass
    this.__patch__(
      this._vnode,
      this.kept,
      false, // hydrating
      true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
}

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
}

/*  */

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else if (
        "development" !== 'production' &&
        "development" !== 'test' &&
        isChrome
      ) {
        console[console.info ? 'info' : 'log'](
          'Download the Vue Devtools extension for a better development experience:\n' +
          'https://github.com/vuejs/vue-devtools'
        );
      }
    }
    if ("development" !== 'production' &&
      "development" !== 'test' &&
      config.productionTip !== false &&
      typeof console !== 'undefined'
    ) {
      console[console.info ? 'info' : 'log'](
        "You are running Vue in development mode.\n" +
        "Make sure to turn on production mode when deploying for production.\n" +
        "See more tips at https://vuejs.org/guide/deployment.html"
      );
    }
  }, 0);
}

/*  */

var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
});



function parseText (
  text,
  delimiters
) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return
  }
  var tokens = [];
  var rawTokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index, tokenValue;
  while ((match = tagRE.exec(text))) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index));
      tokens.push(JSON.stringify(tokenValue));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push(("_s(" + exp + ")"));
    rawTokens.push({ '@binding': exp });
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex));
    tokens.push(JSON.stringify(tokenValue));
  }
  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  }
}

/*  */

function transformNode (el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if ("development" !== 'production' && staticClass) {
    var res = parseText(staticClass, options.delimiters);
    if (res) {
      warn(
        "class=\"" + staticClass + "\": " +
        'Interpolation inside attributes has been removed. ' +
        'Use v-bind or the colon shorthand instead. For example, ' +
        'instead of <div class="{{ val }}">, use <div :class="val">.'
      );
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData (el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + (el.staticClass) + ",";
  }
  if (el.classBinding) {
    data += "class:" + (el.classBinding) + ",";
  }
  return data
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
}

/*  */

function transformNode$1 (el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    {
      var res = parseText(staticStyle, options.delimiters);
      if (res) {
        warn(
          "style=\"" + staticStyle + "\": " +
          'Interpolation inside attributes has been removed. ' +
          'Use v-bind or the colon shorthand instead. For example, ' +
          'instead of <div style="{{ val }}">, use <div :style="val">.'
        );
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1 (el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + (el.staticStyle) + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + (el.styleBinding) + "),";
  }
  return data
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
}

/*  */

var decoder;

var he = {
  decode: function decode (html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent
  }
}

/*  */

var isUnaryTag = makeMap(
  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
  'link,meta,param,source,track,wbr'
);

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap(
  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
);

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap(
  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
  'title,tr,track'
);

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
var ncname = '[a-zA-Z_][\\w\\-\\.]*';
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp(("^<" + qnameCapture));
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp(("^<\\/" + qnameCapture + "[^>]*>"));
var doctype = /^<!DOCTYPE [^>]+>/i;
// #7298: escape - to avoid being pased as HTML comment when inlined in page
var comment = /^<!\--/;
var conditionalComment = /^<!\[/;

var IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t'
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\n'; };

function decodeAttr (value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) { return decodingMap[match]; })
}

function parseHTML (html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd));
            }
            advance(commentEnd + 3);
            continue
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(lastTag, html)) {
            advance(1);
          }
          continue
        }
      }

      var text = (void 0), rest = (void 0), next = (void 0);
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (
          !endTag.test(rest) &&
          !startTagOpen.test(rest) &&
          !comment.test(rest) &&
          !conditionalComment.test(rest)
        ) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) { break }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = '';
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text
            .replace(/<!\--([\s\S]*?)-->/g, '$1') // #7298
            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return ''
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if ("development" !== 'production' && !stack.length && options.warn) {
        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""));
      }
      break
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance (n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag () {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match
      }
    }
  }

  function handleStartTag (match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') { delete args[3]; }
        if (args[4] === '') { delete args[4]; }
        if (args[5] === '') { delete args[5]; }
      }
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'
        ? options.shouldDecodeNewlinesForHref
        : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag (tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) { start = index; }
    if (end == null) { end = index; }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if ("development" !== 'production' &&
          (i > pos || !tagName) &&
          options.warn
        ) {
          options.warn(
            ("tag <" + (stack[i].tag) + "> has no matching end tag.")
          );
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /([^]*?)\s+(?:in|of)\s+([^]*)/;
var forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
var stripParensRE = /^\(|\)$/g;

var argRE = /:(.*)$/;
var bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = cached(he.decode);

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;



function createASTElement (
  tag,
  attrs,
  parent
) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    parent: parent,
    children: []
  }
}

/**
 * Convert HTML string to AST.
 */
function parse (
  template,
  options
) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce (msg) {
    if (!warned) {
      warned = true;
      warn$2(msg);
    }
  }

  function closeElement (element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
    // apply post-transforms
    for (var i = 0; i < postTransforms.length; i++) {
      postTransforms[i](element, options);
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    start: function start (tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        "development" !== 'production' && warn$2(
          'Templates should only be responsible for mapping the state to the ' +
          'UI. Avoid placing tags with side-effects in your templates, such as ' +
          "<" + tag + ">" + ', as they will not be parsed.'
        );
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
        // element-scope stuff
        processElement(element, options);
      }

      function checkRootConstraints (el) {
        {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce(
              "Cannot use <" + (el.tag) + "> as component root element because it may " +
              'contain multiple nodes.'
            );
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce(
              'Cannot use v-for on stateful component root element because ' +
              'it renders multiple elements.'
            );
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else {
          warnOnce(
            "Component template should contain exactly one root element. " +
            "If you are using v-if on multiple elements, " +
            "use v-else-if to chain them instead."
          );
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) { // scoped slot
          currentParent.plain = false;
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        closeElement(element);
      }
    },

    end: function end () {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      closeElement(element);
    },

    chars: function chars (text) {
      if (!currentParent) {
        {
          if (text === template) {
            warnOnce(
              'Component template requires a root element, rather than just text.'
            );
          } else if ((text = text.trim())) {
            warnOnce(
              ("text \"" + text + "\" outside root element will be ignored.")
            );
          }
        }
        return
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE &&
        currentParent.tag === 'textarea' &&
        currentParent.attrsMap.placeholder === text
      ) {
        return
      }
      var children = currentParent.children;
      text = inPre || text.trim()
        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
        // only preserve whitespace if its not right after a starting tag
        : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var res;
        if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: res.expression,
            tokens: res.tokens,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    },
    comment: function comment (text) {
      currentParent.children.push({
        type: 3,
        text: text,
        isComment: true
      });
    }
  });
  return root
}

function processPre (el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs (el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement (element, options) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = !element.key && !element.attrsList.length;

  processRef(element);
  processSlot(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
}

function processKey (el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if ("development" !== 'production' && el.tag === 'template') {
      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
    }
    el.key = exp;
  }
}

function processRef (el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor (el) {
  var exp;
  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
    var res = parseFor(exp);
    if (res) {
      extend(el, res);
    } else {
      warn$2(
        ("Invalid v-for expression: " + exp)
      );
    }
  }
}



function parseFor (exp) {
  var inMatch = exp.match(forAliasRE);
  if (!inMatch) { return }
  var res = {};
  res.for = inMatch[2].trim();
  var alias = inMatch[1].trim().replace(stripParensRE, '');
  var iteratorMatch = alias.match(forIteratorRE);
  if (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, '');
    res.iterator1 = iteratorMatch[1].trim();
    if (iteratorMatch[2]) {
      res.iterator2 = iteratorMatch[2].trim();
    }
  } else {
    res.alias = alias;
  }
  return res
}

function processIf (el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions (el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else {
    warn$2(
      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
      "used on element <" + (el.tag) + "> without corresponding v-if."
    );
  }
}

function findPrevElement (children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i]
    } else {
      if ("development" !== 'production' && children[i].text !== ' ') {
        warn$2(
          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
          "will be ignored."
        );
      }
      children.pop();
    }
  }
}

function addIfCondition (el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce (el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

function processSlot (el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if ("development" !== 'production' && el.key) {
      warn$2(
        "`key` does not work on <slot> because slots are abstract outlets " +
        "and can possibly expand into multiple elements. " +
        "Use the key on a wrapping element instead."
      );
    }
  } else {
    var slotScope;
    if (el.tag === 'template') {
      slotScope = getAndRemoveAttr(el, 'scope');
      /* istanbul ignore if */
      if ("development" !== 'production' && slotScope) {
        warn$2(
          "the \"scope\" attribute for scoped slots have been deprecated and " +
          "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " +
          "can also be used on plain elements in addition to <template> to " +
          "denote scoped slots.",
          true
        );
      }
      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {
      /* istanbul ignore if */
      if ("development" !== 'production' && el.attrsMap['v-for']) {
        warn$2(
          "Ambiguous combined usage of slot-scope and v-for on <" + (el.tag) + "> " +
          "(v-for takes higher priority). Use a wrapper <template> for the " +
          "scoped slot to make it clearer.",
          true
        );
      }
      el.slotScope = slotScope;
    }
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      // preserve slot as an attribute for native shadow DOM compat
      // only for non-scoped slots.
      if (el.tag !== 'template' && !el.slotScope) {
        addAttr(el, 'slot', slotTarget);
      }
    }
  }
}

function processComponent (el) {
  var binding;
  if ((binding = getBindingAttr(el, 'is'))) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs (el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) { // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = camelize(name);
            if (name === 'innerHtml') { name = 'innerHTML'; }
          }
          if (modifiers.camel) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            addHandler(
              el,
              ("update:" + (camelize(name))),
              genAssignmentCode(value, "$event")
            );
          }
        }
        if (isProp || (
          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
          addProp(el, name, value);
        } else {
          addAttr(el, name, value);
        }
      } else if (onRE.test(name)) { // v-on
        name = name.replace(onRE, '');
        addHandler(el, name, value, modifiers, false, warn$2);
      } else { // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        addDirective(el, name, rawName, value, arg, modifiers);
        if ("development" !== 'production' && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      {
        var res = parseText(value, delimiters);
        if (res) {
          warn$2(
            name + "=\"" + value + "\": " +
            'Interpolation inside attributes has been removed. ' +
            'Use v-bind or the colon shorthand instead. For example, ' +
            'instead of <div id="{{ val }}">, use <div :id="val">.'
          );
        }
      }
      addAttr(el, name, JSON.stringify(value));
      // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation
      if (!el.component &&
          name === 'muted' &&
          platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true');
      }
    }
  }
}

function checkInFor (el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true
    }
    parent = parent.parent;
  }
  return false
}

function parseModifiers (name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) { ret[m.slice(1)] = true; });
    return ret
  }
}

function makeAttrsMap (attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if (
      "development" !== 'production' &&
      map[attrs[i].name] && !isIE && !isEdge
    ) {
      warn$2('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag (el) {
  return el.tag === 'script' || el.tag === 'style'
}

function isForbiddenTag (el) {
  return (
    el.tag === 'style' ||
    (el.tag === 'script' && (
      !el.attrsMap.type ||
      el.attrsMap.type === 'text/javascript'
    ))
  )
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug (attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res
}

function checkForAliasModel (el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2(
        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
        "You are binding v-model directly to a v-for iteration alias. " +
        "This will not be able to modify the v-for source array because " +
        "writing to the alias is like modifying a function local variable. " +
        "Consider using an array of objects and use v-model on an object property instead."
      );
    }
    _el = _el.parent;
  }
}

/*  */

/**
 * Expand input[v-model] with dyanmic type bindings into v-if-else chains
 * Turn this:
 *   <input v-model="data[type]" :type="type">
 * into this:
 *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
 *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
 *   <input v-else :type="type" v-model="data[type]">
 */

function preTransformNode (el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;
    if (!map['v-model']) {
      return
    }

    var typeBinding;
    if (map[':type'] || map['v-bind:type']) {
      typeBinding = getBindingAttr(el, 'type');
    }
    if (!map.type && !typeBinding && map['v-bind']) {
      typeBinding = "(" + (map['v-bind']) + ").type";
    }

    if (typeBinding) {
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? ("&&(" + ifCondition + ")") : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
      // 1. checkbox
      var branch0 = cloneASTElement(el);
      // process for on the main node
      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed
      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      });
      // 2. add radio else-if condition
      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      });
      // 3. other
      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0
    }
  }
}

function cloneASTElement (el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent)
}

var model$2 = {
  preTransformNode: preTransformNode
}

var modules$1 = [
  klass$1,
  style$1,
  model$2
]

/*  */

function text (el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
  }
}

/*  */

function html (el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
}

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize (root, options) {
  if (!root) { return }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1 (keys) {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
    (keys ? ',' + keys : '')
  )
}

function markStatic$1 (node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots (node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true;
      return
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic (node) {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}

function isDirectChildOfTemplateFor (node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false
    }
    if (node.for) {
      return true
    }
  }
  return false
}

/*  */

var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/;

// KeyboardEvent.keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// KeyboardEvent.key aliases
var keyNames = {
  esc: 'Escape',
  tab: 'Tab',
  enter: 'Enter',
  space: ' ',
  // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.
  up: ['Up', 'ArrowUp'],
  left: ['Left', 'ArrowLeft'],
  right: ['Right', 'ArrowRight'],
  down: ['Down', 'ArrowDown'],
  'delete': ['Backspace', 'Delete']
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers (
  events,
  isNative,
  warn
) {
  var res = isNative ? 'nativeOn:{' : 'on:{';
  for (var name in events) {
    res += "\"" + name + "\":" + (genHandler(name, events[name])) + ",";
  }
  return res.slice(0, -1) + '}'
}

function genHandler (
  name,
  handler
) {
  if (!handler) {
    return 'function(){}'
  }

  if (Array.isArray(handler)) {
    return ("[" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + "]")
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);

  if (!handler.modifiers) {
    if (isMethodPath || isFunctionExpression) {
      return handler.value
    }
    /* istanbul ignore if */
    return ("function($event){" + (handler.value) + "}") // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = (handler.modifiers);
        genModifierCode += genGuard(
          ['ctrl', 'shift', 'alt', 'meta']
            .filter(function (keyModifier) { return !modifiers[keyModifier]; })
            .map(function (keyModifier) { return ("$event." + keyModifier + "Key"); })
            .join('||')
        );
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath
      ? ("return " + (handler.value) + "($event)")
      : isFunctionExpression
        ? ("return (" + (handler.value) + ")($event)")
        : handler.value;
    /* istanbul ignore if */
    return ("function($event){" + code + handlerCode + "}")
  }
}

function genKeyFilter (keys) {
  return ("if(!('button' in $event)&&" + (keys.map(genFilterCode).join('&&')) + ")return null;")
}

function genFilterCode (key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return ("$event.keyCode!==" + keyVal)
  }
  var keyCode = keyCodes[key];
  var keyName = keyNames[key];
  return (
    "_k($event.keyCode," +
    (JSON.stringify(key)) + "," +
    (JSON.stringify(keyCode)) + "," +
    "$event.key," +
    "" + (JSON.stringify(keyName)) +
    ")"
  )
}

/*  */

function on (el, dir) {
  if ("development" !== 'production' && dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) { return ("_g(" + code + "," + (dir.value) + ")"); };
}

/*  */

function bind$1 (el, dir) {
  el.wrapData = function (code) {
    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")")
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
}

/*  */

var CodegenState = function CodegenState (options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };
  this.onceId = 0;
  this.staticRenderFns = [];
};



function generate (
  ast,
  options
) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: ("with(this){return " + code + "}"),
    staticRenderFns: state.staticRenderFns
  }
}

function genElement (el, state) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data = el.plain ? undefined : genData$2(el, state);

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code
  }
}

// hoist static sub-trees out
function genStatic (el, state) {
  el.staticProcessed = true;
  state.staticRenderFns.push(("with(this){return " + (genElement(el, state)) + "}"));
  return ("_m(" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
}

// v-once
function genOnce (el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break
      }
      parent = parent.parent;
    }
    if (!key) {
      "development" !== 'production' && state.warn(
        "v-once can only be used inside v-for that is keyed. "
      );
      return genElement(el, state)
    }
    return ("_o(" + (genElement(el, state)) + "," + (state.onceId++) + "," + key + ")")
  } else {
    return genStatic(el, state)
  }
}

function genIf (
  el,
  state,
  altGen,
  altEmpty
) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)
}

function genIfConditions (
  conditions,
  state,
  altGen,
  altEmpty
) {
  if (!conditions.length) {
    return altEmpty || '_e()'
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions, state, altGen, altEmpty)))
  } else {
    return ("" + (genTernaryExp(condition.block)))
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp (el) {
    return altGen
      ? altGen(el, state)
      : el.once
        ? genOnce(el, state)
        : genElement(el, state)
  }
}

function genFor (
  el,
  state,
  altGen,
  altHelper
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';

  if ("development" !== 'production' &&
    state.maybeComponent(el) &&
    el.tag !== 'slot' &&
    el.tag !== 'template' &&
    !el.key
  ) {
    state.warn(
      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
      "v-for should have explicit keys. " +
      "See https://vuejs.org/guide/list.html#key for more info.",
      true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + ((altGen || genElement)(el, state)) +
    '})'
}

function genData$2 (el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) { data += dirs + ','; }

  // key
  if (el.key) {
    data += "key:" + (el.key) + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + (el.ref) + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + (el.tag) + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:{" + (genProps(el.attrs)) + "},";
  }
  // DOM props
  if (el.props) {
    data += "domProps:{" + (genProps(el.props)) + "},";
  }
  // event handlers
  if (el.events) {
    data += (genHandlers(el.events, false, state.warn)) + ",";
  }
  if (el.nativeEvents) {
    data += (genHandlers(el.nativeEvents, true, state.warn)) + ",";
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + (el.slotTarget) + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += (genScopedSlots(el.scopedSlots, state)) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data
}

function genDirectives (el, state) {
  var dirs = el.directives;
  if (!dirs) { return }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']'
  }
}

function genInlineTemplate (el, state) {
  var ast = el.children[0];
  if ("development" !== 'production' && (
    el.children.length !== 1 || ast.type !== 1
  )) {
    state.warn('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
  }
}

function genScopedSlots (
  slots,
  state
) {
  return ("scopedSlots:_u([" + (Object.keys(slots).map(function (key) {
      return genScopedSlot(key, slots[key], state)
    }).join(',')) + "])")
}

function genScopedSlot (
  key,
  el,
  state
) {
  if (el.for && !el.forProcessed) {
    return genForScopedSlot(key, el, state)
  }
  var fn = "function(" + (String(el.slotScope)) + "){" +
    "return " + (el.tag === 'template'
      ? el.if
        ? ((el.if) + "?" + (genChildren(el, state) || 'undefined') + ":undefined")
        : genChildren(el, state) || 'undefined'
      : genElement(el, state)) + "}";
  return ("{key:" + key + ",fn:" + fn + "}")
}

function genForScopedSlot (
  key,
  el,
  state
) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
  el.forProcessed = true; // avoid recursion
  return "_l((" + exp + ")," +
    "function(" + alias + iterator1 + iterator2 + "){" +
      "return " + (genScopedSlot(key, el, state)) +
    '})'
}

function genChildren (
  el,
  state,
  checkSkip,
  altGenElement,
  altGenNode
) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 &&
      el$1.for &&
      el$1.tag !== 'template' &&
      el$1.tag !== 'slot'
    ) {
      return (altGenElement || genElement)(el$1, state)
    }
    var normalizationType = checkSkip
      ? getNormalizationType(children, state.maybeComponent)
      : 0;
    var gen = altGenNode || genNode;
    return ("[" + (children.map(function (c) { return gen(c, state); }).join(',')) + "]" + (normalizationType ? ("," + normalizationType) : ''))
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType (
  children,
  maybeComponent
) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue
    }
    if (needsNormalization(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
      res = 2;
      break
    }
    if (maybeComponent(el) ||
        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
      res = 1;
    }
  }
  return res
}

function needsNormalization (el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
}

function genNode (node, state) {
  if (node.type === 1) {
    return genElement(node, state)
  } if (node.type === 3 && node.isComment) {
    return genComment(node)
  } else {
    return genText(node)
  }
}

function genText (text) {
  return ("_v(" + (text.type === 2
    ? text.expression // no need for () because already wrapped in _s()
    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
}

function genComment (comment) {
  return ("_e(" + (JSON.stringify(comment.text)) + ")")
}

function genSlot (el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? ("," + children) : '');
  var attrs = el.attrs && ("{" + (el.attrs.map(function (a) { return ((camelize(a.name)) + ":" + (a.value)); }).join(',')) + "}");
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')'
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent (
  componentName,
  el,
  state
) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return ("_c(" + componentName + "," + (genData$2(el, state)) + (children ? ("," + children) : '') + ")")
}

function genProps (props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    /* istanbul ignore if */
    {
      res += "\"" + (prop.name) + "\":" + (transformSpecialNewlines(prop.value)) + ",";
    }
  }
  return res.slice(0, -1)
}

// #3895, #4268
function transformSpecialNewlines (text) {
  return text
    .replace(/\u2028/g, '\\u2028')
    .replace(/\u2029/g, '\\u2029')
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + (
  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
  'super,throw,while,yield,delete,export,import,return,switch,default,' +
  'extends,finally,continue,debugger,function,arguments'
).split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + (
  'delete,typeof,void'
).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors (ast) {
  var errors = [];
  if (ast) {
    checkNode(ast, errors);
  }
  return errors
}

function checkNode (node, errors) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          if (name === 'v-for') {
            checkFor(node, ("v-for=\"" + value + "\""), errors);
          } else if (onRE.test(name)) {
            checkEvent(value, (name + "=\"" + value + "\""), errors);
          } else {
            checkExpression(value, (name + "=\"" + value + "\""), errors);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], errors);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, errors);
  }
}

function checkEvent (exp, text, errors) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);
  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    errors.push(
      "avoid using JavaScript unary operator as property name: " +
      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim())
    );
  }
  checkExpression(exp, text, errors);
}

function checkFor (node, text, errors) {
  checkExpression(node.for || '', text, errors);
  checkIdentifier(node.alias, 'v-for alias', text, errors);
  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
}

function checkIdentifier (
  ident,
  type,
  text,
  errors
) {
  if (typeof ident === 'string') {
    try {
      new Function(("var " + ident + "=_"));
    } catch (e) {
      errors.push(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())));
    }
  }
}

function checkExpression (exp, text, errors) {
  try {
    new Function(("return " + exp));
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      errors.push(
        "avoid using JavaScript keyword as property name: " +
        "\"" + (keywordMatch[0]) + "\"\n  Raw expression: " + (text.trim())
      );
    } else {
      errors.push(
        "invalid expression: " + (e.message) + " in\n\n" +
        "    " + exp + "\n\n" +
        "  Raw expression: " + (text.trim()) + "\n"
      );
    }
  }
}

/*  */

function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop
  }
}

function createCompileToFunctionFn (compile) {
  var cache = Object.create(null);

  return function compileToFunctions (
    template,
    options,
    vm
  ) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;

    /* istanbul ignore if */
    {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          );
        }
      }
    }

    // check cache
    var key = options.delimiters
      ? String(options.delimiters) + template
      : template;
    if (cache[key]) {
      return cache[key]
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    {
      if (compiled.errors && compiled.errors.length) {
        warn$$1(
          "Error compiling template:\n\n" + template + "\n\n" +
          compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
          vm
        );
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(function (msg) { return tip(msg, vm); });
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors)
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1(
          "Failed to generate render function:\n\n" +
          fnGenErrors.map(function (ref) {
            var err = ref.err;
            var code = ref.code;

            return ((err.toString()) + " in\n\n" + code + "\n");
        }).join('\n'),
          vm
        );
      }
    }

    return (cache[key] = res)
  }
}

/*  */

function createCompilerCreator (baseCompile) {
  return function createCompiler (baseOptions) {
    function compile (
      template,
      options
    ) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];
      finalOptions.warn = function (msg, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        // merge custom modules
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          );
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      var compiled = baseCompile(template, finalOptions);
      {
        errors.push.apply(errors, detectErrors(compiled.ast));
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile (
  template,
  options
) {
  var ast = parse(template.trim(), options);
  if (options.optimize !== false) {
    optimize(ast, options);
  }
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;

/*  */

// check whether current browser encodes a char inside attribute values
var div;
function getShouldDecode (href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0
}

// #3663: IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML
});

var mount = Vue.prototype.$mount;
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    "development" !== 'production' && warn(
      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
    );
    return this
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if ("development" !== 'production' && !template) {
            warn(
              ("Template element not found or is empty: " + (options.template)),
              this
            );
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        {
          warn('invalid template option:' + template, this);
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        mark('compile end');
        measure(("vue " + (this._name) + " compile"), 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating)
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML (el) {
  if (el.outerHTML) {
    return el.outerHTML
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML
  }
}

Vue.compile = compileToFunctions;

return Vue;

})));
</script>
    
  
    <style type="text/css">
    html, body{
      margin: 0;
      padding: 0;
    }
.phone-view{
	background-color: #25263A;
	padding-top: 70px;
	padding-bottom: 77px;
}
[v-cloak] {
  display: none;
}
.phone-view .bantitle{
  display: none;
   font-family: 'PingFangSC-Regular', 'Arial',sans-serif;
   font-size: 24px;
   text-align: center;
   height: 33px;
   line-height: 33px;
   margin-bottom: 36px;
   color: #fff;
}
.phone-view .titles{
	font-family: 'PingFangSC-Regular', 'Arial',sans-serif;
	font-size:15px;
	height: 21px;
	line-height:21px;
	color: #fff;
	text-align: center;
	margin-bottom: 21px;
}
.phone-view .titles span.spimg{
	display: inline-block;
	width: 20px;
	height: 20px;
	line-height: 20px;
	border-radius: 10px;
	border: 1px solid #00E2C8;
	color: #00E2C8;
	margin-right:7px;
}
.phone-view .detailimg{
    text-align: center;
    font-size: 0px;
}
.phone-view .first{
	margin-bottom: 47px;
}
.phone-view .first img{
    width: 8.0rem;
}
.phone-view .second{
	margin-bottom: 29px;
}
.phone-view .second img{
    width: 8.746667rem;
}
.phone-view .three{
	margin-bottom: 40px;
}
.phone-view .three img{
    width: 8.0rem;
}
.phone-view .setup{
    text-align: center;
    margin-bottom: 0.733333rem;
}
.phone-view .setup span{
    text-align: center;
    font-family: 'PingFangSC-Regular', 'Arial',sans-serif;
    font-size: 16px;
    height: 22px;
    line-height: 22px;
    color: #fff;
}
.phone-view .addphone{
	font-family: 'PingFangSC-Regular', 'Arial',sans-serif;
    font-size: 14px;
    color:#AEAFC5;
    height: 20px;
    line-height: 20px;
    text-align: center;
}
/*.firstbk{
	width: 300px;
	height: 300px;
	background: url(./img/1.png?__inline);
	background: -webkit-image-set(
        url(./img/1.png?__inline) 2x,
        url(./img/1_3x.png?__inline) 3x
      );
	background-position: center;
	background-repeat: no-repeat;
}
*/</style>
</head>
  <body data-ext-version="1.4.2" style="font-size: 12px;">
    <!-- 路由外链 -->
    <div id="phone-view" class="phone-view"><div class="bantitle">请链接得图全景相机</div> <div class="titles"><span class="spimg">1</span><span>打开相机电源开关</span></div> <div class="first detailimg"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAG4CAYAAACZypnDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6Q0REMDVGRTYyQTcwMTFFODgyNDNBODUzRUY2RTkwMTkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6Q0REMDVGRTcyQTcwMTFFODgyNDNBODUzRUY2RTkwMTkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCNjFFQUJGRjJBNkYxMUU4ODI0M0E4NTNFRjZFOTAxOSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCNjFFQUMwMDJBNkYxMUU4ODI0M0E4NTNFRjZFOTAxOSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PuaPVAAAAecaSURBVHja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"></div> <div class="titles"><span class="spimg">2</span><span>通过手机设置链接相机WIFI</span></div> <div class="second detailimg"><img src="data:image/png;base64,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CmTOULIgEiABEiABEiABEigNAlVLo5vF38tly5bJlVdeKffff7/tzG677SavvPKKNG7cuPg7l8cerFy5UmbPni2LFy8WbP/1r3+VzTbbTBo0aJCzVm0odfz++++yaNEi+fnnn2X16tVSu3Zt2XzzzS2vnMHSgn766SdbB+orKyuTOnXq2DowLhQSIAESIIFCIjBztJGIP1NkMnz4cFOlShWjeHP+N2/evLzRGDt2rNGbdUqf+vfvn7f2lLfi7777zqjSm9KPuLHCWKpSZ1ShM7vuuqs5++yzzeeff17e6m2+CRMmmE6dOpmNNtooth1/+9vfzMUXX2x+++23xPUlqaNPnz5GFbPEdUycONH2o2rVqhn7cdFFFyWuY8GCBeaKK66w7OPGCMfA6tRTTy3X2KhCas455xyz5ZZbxvYD9Wy11VY27ddff52YFzOQAAmQAAlkTyBKL7T79YJcpn/ivtjtwD/TuENgT2F/1Ru36E1PYLGLElhPJk2aJH/88YdNUq9ePdlmm21EFYqoLPKXv/xFXnzxRWtxiUy0ng/AIvPyyy9bC82hhx4qO+6443quMffFz5gxQw4++GCZPn26LXyLLbaQFi1aWIuWvzY9xWXFihV2HH/88UeZP3++/7DdhhV24MCBgs9sZNasWXL44YfLlClTvOTt27eXk046Sfbbbz/ZZJNNBGneeOMNGTRokOXsEp533nnW+lutWjW3K/QT1kzUMXnyZO/47rvvbuvYf//9vTrefPNNef755+WHH37w0iWp44gjjrDnsMscrAPtQD9eeOEF+f77710y6dmzpzzwwAMS1w9wv/zyyz1rNzI3adJEunXrJgceeKBsv/321jKIcj/99FN59tln5csvv/TqaN68uQwbNky22247b1/YxpIlS+Sss86yvyt3XBVEe36grq233tqeF//9739lxIgR8tJLL4kqtS6pdO/eXR588MGcW0C9CrhBAiRAAiVMoGzWmOjeN+m4Vn+M0zKz11WLJ+X//vc/ozc3z9rRo0cPo8pZ8XSgiFuqykAK++OOOy7r3vz666/mueeeS7OItWzZ0sycOTO2HFim/Rbcrl27Gp0qjc2jSp6pVauWd54cc8wxsdbId955J3EdqmhVqA59kMjYD9Sh081eP44++ujYfuC4XjXsX6NGjQysqZnkq6++Mk2bNvXywZqoCmZkts8+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nTrZVxQiLV4R53zu/HkRyer8ALFeHqYRMwmmTRGYgKl3CPww46JhM5UXdxy+an72cWnRP7QF7gBYcBrRuv5o57i8UcfgeoAAFKxFiPU6P/74Y+vrhwWuEZSD8YB/IKZe8QpA+OslZeHqUAVXsA5oVB14/R+mpFFHNuPk7xN8LtEP1IF+YKoZPov+fuBc07fzSLdu3RLVgf52797d/qFO+JliYXNEu8P3EPUiGAdro2K1ASwDhVcjYvF71JdEdtllF7swOMrDKxbVAmsDzRDtjUhvnJs4ZxB4g/Ma5w4CpbCfQgIkQAIkkD8Ca6/CsEBGiGncIeIId2/oBLDECt4vDYUhqRIVZINoW6xLiehfCgmQAAmQAAmQQGETKJu11jc/tJVNOpYlN7uFlsSdGyIBRLsiiCRpIEUYC7xpRac1qUCGweE+EiABEiABEigyAlQgi2zAKrO5mM7NNlq5MtvFukiABEiABEiABPJLgMv45Jc/aycBEiABEiABEiCBoiNABbLohowNJgESIAESIAESIIH8EqACmV/+rJ0ESIAESIAESIAEio4AFciiGzI2mARIgARIgARIgATyS4AKZH75s3YSIAESIAESIAESKDoCVCCLbsjYYBIgARIgARIgARLILwEqkPnlz9pJgARIgARIgARIoOgIUIEsuiFjg0mABEiABEiABEggvwSoQOaXP2snARIgARIgARIggaIjQAWy6IaMDSYBEiABEiABEiCB/BKgAplf/qydBEiABEiABEiABIqOABXIohsyNpgESIAESIAESIAE8kuACmR++bN2EiABEiABEiABEig6AlQgi27I2GASIAESIAESIAESyC+BquuqX6Cf9cKaMnnF79K62iZhhwpqnzFGli9fIWUF1So2hgRIgARIgARIgASKi8DUVX/ENRg6o6xTIMueFjEXh6Vuu2CaPFKnmZxds27Y4YLZV1ZWJjVqVC+Y9rAhJEACJEACJEACJFBsBP5v6ULp8euMmGZDZxSfwW7W6NFipENMDh4iARIgARIgARIgARIoVQJlMkYad+yI7v/pA4kdVcquKVUm7DcJkAAJkAAJkAAJkEAEAeiI65RHpAh3GZw9pqdaI/uJMYXv/BjRT+4mARIgARIgARIgARKoAIGyst9VU7xUGnUYGCwlXIH0pzKmqswZu7cqlDuLKWsgZWZT/+Fst3vVrNcr27RMRwIkQAIkQAIkQAIkkJnAQ0sXPJQ5VRYpTNkS1fHmqsL4hTRsP1LKylbF5cqsQMblTnBMo6RNguRMSgIkQAIkQAIkQAIkkIGABhFXmi7nb8qfPpD+vdwmARIgARIgARIgARIggQgCVCAjwHA3CZAACZAACZAACZBAOAEqkOFcuJcESIAESIAESIAESCCCABXICDDcTQIkQAIkQAIkQAIkEE7Avcow/Cj3Jibw48KfZMXKlRrElBef1sTtZQYSIAESIAESIAESSEqg0rQcRmEnHRqmJwESIAESIAESIIF4AozCjufDoyRAAiRAAiRAAiRAAgVCgD6QBTIQbAYJkAAJkAAJkAAJFAsBKpDFMlJsJwmQAAmQAAmQAAkUCAEqkAUyEGwGCZAACZAACZAACRQLASqQxTJSbCcJkAAJkAAJkAAJFAiBylQgnymQPrMZJEACJEACJEACJLAhEMibblVpy/hglHQpn0b6caf+ddG/+vpHIQESIAESIAESIIFKIbDwd5GnJokMnigydb5IFdWCmtURqbuJyMbVRNasEVm6QmTuYpHZi0RqVhfp1FTk3PYih+0oUn2jSmlmpkrmaYIR+ne5LuEzO1Pi9XX8/wGP3l01LNrXiQAAAABJRU5ErkJggg=="></div> <div class="setup"><span>去设置&gt;&gt;</span></div> <div class="titles"><span class="spimg">3</span><span>链接成功后自动跳转转到拍摄界面</span></div> <div class="three detailimg"><img src="data:image/png;base64,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"></div> <div id="addphone" class="addphone">未能连接成功？请致电0571-28801869</div></div>
    
  
<script type="text/javascript">
    
        new Vue({
            el: '.phone-view',
            components: {
            },
            data: {
                name: 'hello',
                infodata:{},
            },
            created: function() {
               this.handerReady(); 
            },
            ready: function(){
            },
            methods: {
               getQueryString:function(name){
                var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
                var r = window.location.search.substr(1).match(reg);
                if (r != null) return unescape(r[2]);
                return null;
               },
               handerReady:function(){
                 var langData = {
                        'zh-cn': {
                            'bantitle': '请链接得图全景相机',
                            'tit1':'打开相机电源开关',
                            'tit2':'通过手机设置链接相机WIFI',
                            'tit3':'链接成功后自动跳转转到拍摄界面',
                            'setup':'去设置>>',
                            'addphone':'未能连接成功？请致电0571-28801869',
                        },
                        'en-us': {
                            'bantitle': '英文请链接得图全景相机',
                            'tit1':'打开相机电源开关',
                            'tit2':'通过手机设置链接相机WIFI',
                            'tit3':'链接成功后自动跳转转到拍摄界面',
                            'setup':'去设置>>',
                            'addphone':'未能连接成功？请致电0571-28801869',
                        },
                        'zh-tw': {
                            'bantitle': '繁体请链接得图全景相机',
                            'tit1':'打开相机电源开关',
                            'tit2':'通过手机设置链接相机WIFI',
                            'tit3':'链接成功后自动跳转转到拍摄界面',
                            'setup':'去设置>>',
                            'addphone':'未能连接成功？请致电0571-28801869',
                        }
                    };
                 var lang = this.getQueryString('lang');
                 this.$data.infodata = langData[lang] ? langData[lang] : langData['zh-cn'];
               },
               setUp:function(){
                    setTimeout(function() {
                        if( window.detuJsBridge && typeof window.detuJsBridge.openWiFiSetting == 'function' ) {
                            window.detuJsBridge.openWiFiSetting();
                        }else if (window.webkit
                            && window.webkit.messageHandlers
                            && window.webkit.messageHandlers.openWiFiSetting) {
                          // Call iOS interface
                          window.webkit.messageHandlers.openWiFiSetting.postMessage({});
                        } else {
                          // No Android or iOS interface found
                          console.log("No native APIs found.");
                        }
                    }, 50);
               }
            }
        });
    </script>


</body></html>